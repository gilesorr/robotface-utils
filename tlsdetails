#!/usr/bin/env bash
# <|째_째|>
# Created:  2018-06-07
# Purpose:
#     Check TLS certificate details.
#
# TODO:
# - check that the FQDN matches the address contained in the cert, if
#   not "Warning: your URL '...' doesn't match the cert URL '...'"

######################################################################
#                            Help
######################################################################

usage() {
    # Unlike Python's "argparse," Bash's "getopts" doesn't auto-generate
    # the help or keep this "help" output up-to-date: you have to do that.
    cat << EOF
Usage:
    $(basename "${0}") [-h] [-s] <domain-name>

Show HTTP(s) and TLS certificate details.
Do not include the 'http(s)://' leader on the domain name.

-h            show this help and exit
-s            use System versions of 'curl' and 'openssl' (don't search)
EOF
}


######################################################################
#                       Utility Functions
######################################################################

expiry_date() {
    echo "${1}" | ${OPENSSL} x509 -noout -dates | awk 'BEGIN { FS="=" } /notAfter/ { print $2 }'
}

days_to_expiry() {
    expiry_date="$(expiry_date "${1}")"
    if date --version 2>/dev/null | grep -q GNU
    then
        # Linux (or at least GNU)
        expiry_epoch_seconds=$(date --date="${expiry_date}" "+%s")
    else
        # Assuming the Mac version:
        expiry_epoch_seconds=$(date -jf '%b %e %H:%M:%S %Y %Z' "${expiry_date}" "+%s")
    fi
    # and we convert to seconds from the Unix Epoch ...
    now_epoch_seconds=$(date "+%s")
    seconds_to_expiry=$(( expiry_epoch_seconds - now_epoch_seconds ))
    echo "$(( seconds_to_expiry / 60 / 60 / 24 ))"
}

issuer() {
    echo "${1}" | ${OPENSSL} x509 -noout -issuer | awk -F "=" '{ print $4 }' | sed -e 's@/.*@@'
}

tlsversions() {
    successful=""
    failed=""
    for tlsversion in ssl2 ssl3 tls1 tls1_1 tls1_2 tls1_3
    do
        if echo | ${OPENSSL} s_client -connect "${1}":443 -${tlsversion} > /dev/null 2> /dev/null
        then
            successful="${tlsversion} ${successful}"
        else
            failed="${tlsversion} ${failed}"
        fi
    done
    echo "${successful} (tried but unavailable: ${failed})"
}

httpversion() {
    # This 'curl' command returns nothing but a number: '1.1' for most
    # connections, but '2' for HTTP2 sites - and '0' for https:// requests
    # on an unencrypted site.
    unEncNum=$(curl -sI "${1}"         -o/dev/null -w '%{http_version}')
    EncNum=$(curl -sI   "https://${1}" -o/dev/null -w '%{http_version}')
    # since possible return values of EncNum include '1.1', which isn't a
    # valid number in Bash, this is a string comparison:
    if [ "${EncNum}" -eq "0" ]
    then
        echo "${unEncNum}"
    else
        echo "${EncNum}"
    fi
}


######################################################################
#                    Check the command line
######################################################################

if [ $# -lt 1 ]
then
    usage
    exit 1
fi


######################################################################
#                        Load <|째_째|> library
######################################################################

# Get our library of functions:
# shellcheck disable=1090 # Can't follow non-constant source
# shellcheck disable=1091 # Not following ...
source "$(dirname "${0}")/robotface_utils"


######################################################################
#                    Process the command line
######################################################################

# http://wiki.bash-hackers.org/howto/getopts_tutorial
while getopts ":hs" opt
do
    case ${opt} in
        h)
            usage
            exit 0
            ;;
        s)  # use System utilities
            OPENSSL="/usr/bin/openssl"
            ;;

        \?)
            echo "invalid option: -${OPTARG}" >&2
            usage
            exit 1
            ;;

        :)
            echo "option -${OPTARG} requires an argument." >&2
            usage
            exit 1
            ;;
    esac
done
shift $(( OPTIND - 1 ))


######################################################################
#                    Set the curl and openssl versions
######################################################################

if [ $# -ne 1 ]
then
    echo "'$(basename "${0}")' needs a hostname as a parameter."
    usage
    exit 1
else
    domain_name="${1}"
fi

if [ -z "${OPENSSL}" ]
then
    OPENSSL="$(findtls13openssl)"
    if [ -z "${OPENSSL}" ]
    then
        echo "This script requires a version of OpenSSL that supports TLS 1.3, which wasn't found.  Exiting."
        exit 1
    else
        echo "Using OpenSSL:  ${OPENSSL}"
    fi
fi


######################################################################
#                    Check and process our domain name
######################################################################

if [ "$(ishostnamevalid "${domain_name}")" -eq "0" ]
then
    # it's extremely difficult to capture stderr and stdout into two
    # separate variables at once, so use a tmpfile:
    tmpfile="$(/usr/bin/mktemp "/tmp/$(basename "${0}").XXXXXXXX")"
    sclient_out="$(echo | ${OPENSSL} s_client -connect "${domain_name}:443" -servername "${domain_name}" 2>"${tmpfile}")"
    sclient_ret=$?
    # shellcheck disable=SC2034  # sclient_err is unused ...
    sclient_err=$(cat "${tmpfile}")
    rm "${tmpfile}"
    if [ ${sclient_ret} -ne 0 ]
    then
        echo "There was a problem getting the certificate."
        exit 1
    fi
    if [ -z "${sclient_out}" ]
    then
        echo "No certificate returned."
    else
        echo "Expiry Date:    $(expiry_date "${sclient_out}") ($(days_to_expiry "${sclient_out}") days)"
        echo "Issuer:         $(issuer "${sclient_out}")"
        echo "TLS Versions:   $(tlsversions "${domain_name}")"
        echo "HTTP Version:   $(httpversion "${domain_name}")"
    fi
else
    echo "'${1}' appears to be an invalid domain."
fi

